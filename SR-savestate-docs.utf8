Conventions used:
=================
LF => Line Feed (Byte 0x0A).
SP => Space (Byte 0x20)
"foo" => foo as encoded by UTF-8. C escape notation appiles.
Space between byte sequences denotes concatenation.

The SR savestate mechanism and format:
======================================

JRSR archive format:
====================
JRSR archives consist of magic and zero or more textual members. 

Magic:
------
The first five bytes of JRSR archive MUST be "JRSR" LF

Members:
--------
Member starts at line containing "!BEGIN" SP <membername> LF. Member name is UTF-8 encoded, and maximum allowed
length for it is 1024 bytes (256-1024 codepoints, depending on what codepoints). Note that its one <SPACE>, nothing
else. Two <SPACE>s there would encode member with name beginning with <SPACE>. All characters except LF are valid
in member name.

Each line of member is prefixed with "+" and ends in LF. The line ending LF is interpretted part of the stored data.
Member ends when another member starts (!BEGIN) or by explicit end of member line "!END" LF. 

At end of file, there MUST NOT be member in progress. The only things that are allowed outside member is end of file
and starting a member with !BEGIN.

Four-to-five encoding:
======================
Binary members are encoded using "Four-To-Five" encoding in order to make binary stuff into suitable form to pack
into text JRSR archive.

Four-to-five encoding can have five kinds of elements. All LF and <SPACE> characters are ignored no matter where
they occur (even in middle of elements). Other characters allowed in strem include printable ASCII characters
from "!" to "~".

First kind of element is end of stream element. It is encoded as "!". It ends the encoded strem right there. Also,
there is implicit end of strem when underlying text strem ends.

If element is not end of strem element, it encodes 1-4 bytes. In this case, the value to be encoded is first read
as big-endian value of 1 to 4 bytes. It is then written in base 93. Starting from second number, add 34 to these
values. To first byte length-dependent constant is added. This is 34 for 1 byte encoding, 37 for 2 byte encoding,
45 for 3 byte encoding and 66 for 4 byte encoding. Then this sequence of characters gets written out.

To decode, see first byte for how many bytes there are in encoding, then substract length-specific constant from
first byte and 34 from other bytes. Then consider the value to be in base 93. If the value is larger than largest
value representable by encoded bytes, its an error. Otherwise write the bytes out in big-endian.

Current implementation breaks lines into 70 bytes. This is not required.

UTF-8 encoding:
===============
Most textual members are encoded in UTF-8. The allowed characters include all 17 * 65534 - 2048 valid Unicode
non-surrogate codepoints except for control characeters (with exception of CHARACTER TABULATION and LINE FEED).

Line component encoding:
========================
Most textual members are encoded with line component encoding. Line component encoding operates on unicode
codepoints and there's invariably UTF-8 encoding below it. Line component encoding is used to map non-empty arrays of
non-empty Unicode strings into Unicode lines (that then are encoded further by UTF-8 encoding). Essentially member is 
interpretted as array of 1-D arrays.

All empty lines and lines with no components are ignored.

At level of unicode codepoints, the following characters are interpretted as spaces:
- SPACE (Codepoint 32)
- TAB (Codepoint 9)
- Codepoints 0x1680, 0x180E, 0x2028, 0x205F and 0x3000
- Codepoints 0x2000 - 0x200A

The encoding rules are:
- Depth value starts at zero.
- "\\" causes next codepoint to be treated as literal character with no special meaning. MUST NOT be present at end of line.
- Unescaped '(' adds one to depth value. At depth of zero, it is component separator.
- Unescaped ')' substracts one from depth value. Depth value becoming negative is an error. Acts as component separator if
  depth becomes zero.
- Space character with depth of zero is component separator.

Each non-empty component is mapped in order to array of one or more components.


Header section:
===============
Header section is in archive member "header". It uses line component encoding. The first component of each line
is name of header, and subsequent ones are arguments. How many parameters are expected is dependent on what header
it is:

PROJECTID header:
-----------------
Header name: "PROJECTID"
Components: 2
Argument #1: <project-id-string>
Mandatory: Yes

Gives project ID. Project ID is generated when PC is assembled and is then preserved in savestates. It is used for
computing rerecord counts. Emulator treats it as opaque string, the IDs it generates are formed by 48 random hexadecimal
digits.

The algorithm emulator uses for rerecord count is as follows:

SAVESTATEID header:
-------------------
Header name: "SAVESTATEID"
Components: 2
Argument #1: <savestate-id-string>
Mandatory: No

Gives savestate ID. Each savestate has its own savestate ID. Treated as opaque string, but generated as 48 random
hexadecimal digits. The presence of this header signals wheither there is savestate to be loaded. If this header is present,
savestate load will be attempted. If absent, savestate MUST NOT be loaded even if present.

The value is used to prevent loading incompatible savestates in preserve event stream mode and also to find the point
in event stream where one left off.

RERECORDS header:
-----------------
Header name: "SAVESTATEID"
Components: 2
Argument #1: <rerecords>
Mandatory: Yes

Gives rerecord count. PC assembly (except when loading savestate) initializes current rerecord count to zero. 
Must be non-negative.

On loading savestate:
- If project ID matches with previous:
  - If loaded rerecord count is larger or equal to current rerecord count:
    - Current rerecord count is loaded rerecord count + 1.
  - Otherwise
    - Current rerecord count increments by 1.
- Otherwise
  - Current rerecord count is loaded rerecord count + 1.

The current rerecord count at time of save is saved to savestate.

AUTHORS header:
---------------
Header name: "AUTHORS"
Components: 2 or more
Arguments: freeform
Mandatory: No

Gives authors of run. Each argument gives one author. May be present multiple times.

COMMENT header:
---------------
Header name: "COMMENT"
Components: 2 or more
Arguments: freeform
Mandatory: No

Various kinds of freeform data. Not parsed further by emulator.

Initialization segment:
=======================
If SAVESTATEID header isn't present (not a savestate), member "initialization" gives PC initialization parameters
for assembling the PC.

Following parameters are used (space seperates components):

"BIOS" <id>
	Gives Image ID of main system BIOS (mandatory)

"VGABIOS" <id>
	Gives Image ID of VGA BIOS (mandatory).

"HDA" <id>
	Gives Image ID of hda. Present only if system has hard disk hda.

"HDB" <id>
	Gives Image ID of hdb. Present only if system has hard disk hdb.

"HDC" <id>
	Gives Image ID of hdc. Present only if system has hard disk hdc.

"HDD" <id>
	Gives Image ID of hdd. Present only if system has hard disk hdd.

"DISK" <num> <id>
	Gives Image ID of disk in slot <num>. Slot number must be non-negative.

"FDA" <num>
	Gives Image slot to initially put into floppy drive fda. Disk must be of
	floppy type. If none present, no disk is initially put there.

"FDB" <num>
	Gives Image slot to initially put into floppy drive fdb. Disk must be of
	floppy type. If none present, no disk is initially put there.

"CDROM" <num>
	Gives Image slot to initially put into CD-ROM drive hdc. Not allowed if
        hard disk hdc is present. Disk must be of CD-ROM type. If none present
	no disk is initially put there.

"INITIALTIME" <time>
	Number of milliseconds since Unix epoch to system statup time. Allowed range:
	0-4102444799999. Mandatory.

"CPUDIVIDER" <divider>
	Set CPU frequency divider (dividing the 1GHz master clock). Allowed range is 1-256.
	Mandatory.

"MEMORYSIZE" <pages>
	Number of 4KiB pages of RAM memory. Allowed range 256-262144. Mandatory.

"BOOT" <device>
	Set boot device. Valid devices are "FLOPPY" (boot from fda), "HDD" (boot from hda) and "CDROM" 
	(boot from CD).

"LOADMODULEA" <module> <parameters>
	Load module <module> with parameters <parameters>.

"LOADMODULE" <module>
	Load module <module> with no parameters

Event record format:
====================
Event record is in archive member "events". It uses line component encoding. Each line gives an event. First
component of each line gives timestamp. These timestamps MUST be in increasing order and all MUST be non-negative.

The second component of each line is name of class to dispatch to. Further components are passed as-is to event
handlers. "Class" name "SAVESTATE" is special. This takes one additional component which gives the savestate ID
of savestate that occured there. The savestate IDs MUST be unique in entiere event stream.

Timestamp time unit is exactly 1ns of emulated time.

Mouse motion speed change event:
--------------------------------
Dispatch to: org.jpc.emulator.peripheral.Keyboard
Argument #1: Fixed: "MOUSEMOTION"
Argument #2: Number of mickeys per second in X direction (right is positive, decimal).
Argument #3: Number of mickeys per second in Y direction (down is positive, decimal).

Changes speed mouse moves at.

Keyboard keypress/keyrelease event:
-----------------------------------
Dispatch to: org.jpc.emulator.peripheral.Keyboard
Argument #1: Fixed: "KEYEDGE"
Argument #2: Key number. Valid values are 1-95 and 129-223

Send key press or key release. Keys work in togglebutton manner.

Mouse buttons event:
--------------------
Dispatch to: org.jpc.emulator.peripheral.Keyboard
Argument #1: Fixed: "MOUSEBUTTONS"
Argument #2: String. Contains "L" if left mouse button is held. "M" and "R" for middle and right mouse buttons
	in the same manner. Empty value is denoted "-".

Send change in mouse buttons.

Pause event:
------------
Dispatch to: org.jpc.emulator.peripheral.Keyboard
Argument #1: Fixed: "PAUSE"

Send pause key event.

Reboot:
-------
Dispatch to: org.jpc.emulator.PC$ResetButton

Reboots the PC.

Fda disk change:
----------------
Dispatch to: org.jpc.emulator.PC$DiskChanger
Argument #1: Fixed: "FDA"
Argument #2: Number of image slot to put there. 

The disk number MUST be -1 or valid disk number. -1 MUST NOT be used if there is no disk in floppy drive A. This
event causes specified disk to be placed to FDA or FDA disk to be ejected with no replacement if disk number is
-1. The specfied disk if not -1 must be of floppy type. The specified disk if valid must not be in any other
drive.

Fdb disk change:
----------------
Dispatch to: org.jpc.emulator.PC$DiskChanger
Argument #1: Fixed: "FDB"
Argument #2: Number of image slot to put there. 

The disk number MUST be -1 or valid disk number. -1 MUST NOT be used if there is no disk in floppy drive B. This
event causes specified disk to be placed to FDB or FDB disk to be ejected with no replacement if disk number is
-1. The specfied disk if not -1 must be of floppy type. The specified disk if valid must not be in any other
drive.


Change CDROM:
-------------
Dispatch to: org.jpc.emulator.PC$DiskChanger
Argument #1: Fixed: "CDROM"
Argument #2: Number of image slot to put there. 

The disk number MUST be -1 or valid disk number. -1 MUST NOT be used if there is no disk in CDROM. This
event causes specified disk to be placed to CDROM or CDROM disk to be ejected with no replacement if disk number 
is -1. The specfied disk if not -1 must be of CDROM type.

This event has no effect if CDROM is locked.

Write protect floppy:
---------------------
Dispatch to: org.jpc.emulator.PC$DiskChanger
Argument #1: Fixed: "WRITEPROTECT"
Argument #2: Number of image slot to manipulate 

Write protects specified disk. The disk MUST NOT be in any drive and MUST be valid floppy-type disk.

Write unprotect floppy:
-----------------------
Dispatch to: org.jpc.emulator.PC$DiskChanger
Argument #1: Fixed: "WRITEUNPROTECT"
Argument #2: Number of image slot to manipulate 

Write unprotects specified disk. The disk MUST NOT be in any drive and MUST be valid floppy-type disk.

Set joystick buttons:
---------------------
Dispatch to: org.jpc.emulator.peripheral.Joystick
Argument #1: Fixed: "JOYBUTTONS"
Argument #2: String. "A", "B", "C" and "D" are present if apporiate button is held. Empty value is denoted "-".
	"A" and "B" are joystick #1 buttons, "C" and "D" are from joystick #2. "A" and "C" are the triggers and
	"B" and "D" the other buttons.

Set joystick position:
----------------------
Dispatch to: org.jpc.emulator.peripheral.Joystick
Argument #1: Fixed: "JOYAXIS"
Argument #2: Joystick #1 X-axis hold duration in nanoseconds.
Argument #3: Joystick #1 Y-axis hold duration in nanoseconds.
Argument #4: Joystick #2 X-axis hold duration in nanoseconds.
Argument #5: Joystick #2 Y-axis hold duration in nanoseconds.

